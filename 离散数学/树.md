# 树

> 在KB-P329定义16.1下面提到，这一章的“回路”都会指简单或初级回路，所以后面很多地方课本上写的都是回路不是圈。但是我们不采取这样的方法，我们仍然使用圈（初级回路）这个称呼

## 定义、树判定的充要条件和树叶数量定理

### 定义

连通无圈的无向图就是无向树，简称树。每个连通分支都是树的无向图被称为森林

平凡图被称为平凡树。树中悬挂顶点（也就是度为1的点）被称为树叶；度数大于等于2的顶点被称为分支点



### 树判定的充要条件

注意这里是充要条件，所以这里既是树的性质，也是判断树的方法



设$G=<V,E>$是$n$阶$m$条边的无向图，则

1. $G$是树（也就是说$G$连通没有圈）
2. $G$中任意两点之间存在唯一的路径
3. $G$中无圈，且$m=n-1$
4. $G$连通，且$m=n-1$
5. $G$连通且每一条边都是桥
6. $G$中没有圈，但在任何两个不同顶点之间加一条新边之后所得图有唯一一个含新边的圈



这之中，<1>、<2>、<5>和<6>是很容易相互证明的，<3>和<4>的证明需要用到“$n$阶无向图连通则边数大于等于$n-1$”，并且都可以用归纳法证明，可以翻书查阅

<3><4>给出了一个树边和点的关系，这让树的度和也与点的数量直接相关，这在后面会经常用到



### 树叶数量定理

非平凡树至少有两个叶子结点



证明：对于$n$阶($n\ge 2$)树，假设有$x$个叶子结点，则有$n-x$个分支点。根据叶子结点和分支点的定义，$x+2(n-x)\le \sum d$，$\sum d$为度数和。由于$\sum d=2n-2$，所以$2n-x\le 2n-2$，也就是$x\ge 2$





## 生成树

### 相关定义

对于无向图$G$，若$T\subseteq G$（也就是$T$是$G$的生成子图）且$T$是树，则称$T$是$G$的生成树。生成树并不一定唯一

若$e\in E(G)$且$e\in E(T)$，则称$e$是$T$的树枝。相对的若$e\in E(G)$但是$e\notin E(T)$，则称$e$是$T$的弦

称$T$的所有弦导出的子图为$T$的余树，记作$\overline{T}$。容易看出，$|E(\overline{T})|=m-n+1$



注意，余树不是树，甚至不一定连通



### 生成树构造方法

定理：无向连通图一定存在生成树；有生成树的图一定是连通图



对于一张连通图$G_0$，生成树$T$的一种构造方法如下（避圈法）：

1. 如果$G_k$没有圈，那么$T=G_k$
2. 如果$G_k$有圈，设为$C_k$，选$\forall e\in E(C_k)$，另$G_{k+1}=G_k-\{e\}$

重复上面两个过程，一定可以得到树

这是因为，首先最后的图一定没有圈，其次删去圈上的边不会影响图的连通性，所以最后的图一定连通。连通无圈，那就是树了



### 生成树导出的点边数量关系

设$G$为$n$阶$m$条边的无向连通图，则$m\ge n-1$

这是根据树的边点关系导出的



### 圈与弦

> 后面的讨论在老师的PPT中加了限定语，更好理解区分

下面都是对无向连通图$G=<V,E>$（$n=|V|,m=|E|$）和其某棵生成树$T$讨论

#### 无向图的圈中一定有弦

$\forall C\subseteq G$，若$C$为圈，$E(C)\cap E(\overline{T})\neq \varnothing$



如果圈中没有弦，那么圈的边一定在$T$中，这样$T$有圈，与$T$是树矛盾



#### 弦连接在生成树上后产生唯一的圈

设$e_{1}',e_{2}',\cdots e_{m-n+1}'$是$T$对应的弦，$C_{r}$是弦$e'_i$和其他树枝构成的圈（换句话说，这里的圈只有一个弦$e'_i$，剩下的都是树枝），其为$T$添加弦$e_{r}'$后产生的唯一的回路（根据树判定充要条件之<6>）

称$C_r$为$G$的对应弦$e_r'$的基本回路或基本圈，称$\{C_1,C_2,\cdots C_{n-m+1}\}$为$G$对应$T$的基本回路系统，称$m-n+1$为$G$的圈秩，记$\xi(G)$（读作“克西”）



注意$C_r$是由唯一的弦和$T$中其他边连接的，且“$T$中其他边”就是弦连接的两点在树上唯一的路径

$C_r$是回路，应该用路径的表示方法，也就是$e_4e_5e_6$这样的



### 边割集与树枝

下面都是对无向连通图$G=<V,E>$（$n=|V|,m=|E|$）和其某棵生成树$T$讨论

#### 无向图的边割集中一定有生成树的树枝

$E'\subseteq E$，若$E'$是边割集，则$E'\cap E(T)\neq \varnothing$



证明和上面一样，都是反证



#### 一条生成树的树枝与弦构成唯一的边割集

设$e_1,e_2,\cdots e_{n-1}$是$T$的边（也就是生成树的树枝），$S_i$是树枝$e_i$和其他弦构成的边割集（换句话说，这里的边割集只有一个数值$e_i$，剩下的都是弦），设$e_i$将树分割成两个子图$T_1$和$T_2$，则这个边割集应该分割$G$成$G[V(T_1)]$和$G[V(T_2)]$两部分，并且是唯一的

称$S_i$为$G$对应树枝$e_i$的基本割集，称$\{S_1,S_2,\cdots S_{n-1}\}$为$G$对应$T$的基本割集系统，称$n-1$为$G$的割集秩，记作$\eta(G)$（读作“依塔”）



这里基本割集的唯一性是这么证明的：假设我们选的树枝是$e$，其将树分割成$T_1$和$T_2$，根据定义，对应割集$S$不能再包括任何树枝了，这样我们知道，无论再选任何边，$T_1$里面的点一定是连通的，$T_2$里面的点也一定是连通的（很明显，如果不连通了一定删了$T$里面的边）。所以我们知道$S$会且只会将树分成$G[V(T_1)]$和$G[V(T_2)]$两部分，记作$G_1,G_2$。如果想要把$G$变成$G_1,G_2$两部分，我们有且仅有一种删法：删去$\forall v_1\in G_1,v_2\in G_2$的边$(v_1,v_2)$，也就是$S=\{(v_1,v_2)\ |\ \forall v_1\in G_1,v_2\in G_2 \}$。我们很容易证明$S$中只有一条树枝（如果有两条，就不满足树任意两点之间只有一条路径的性质了）

说起来还是很复杂的。。。如果能画个图就很方便了（~~可惜我懒的画~~）



### 最小生成树(MST)

#### 定义

无向连通带权图$G=<V,E,W>$的权最小的生成树

图权的定义：$W(G)=\sum\limits_{e\in E}W(e)$，也就是每一条边的权值和



#### MST的充要条件

设$T$是五无向连通带权图$G=<V,E,W>$的生成树，则

$T$是最小生成树$\Leftrightarrow\forall e\in E(T),e$是基本割集$S_e$的权值最小的边$\Leftrightarrow\forall e\in E(\overline{T}),e$是基本回路$C_e$的权值最大的边



#### Kruskal

直接看流程图：

<img src="树资源库/截屏2021-04-07 12.41.38.png" style="zoom:50%;" />

就是对边排序-从小到大选边-如果边加进去不会形成环就加入，否则不加入



算法的正确性有两种证明方式

1. 一种利用上述充要条件的证明：
   1. 首先明确，得到的一定是生成树
   2. 其次，对于上述算法得到的树，$\forall e\in E(\overline{T}),e$是基本回路$C_e$的权值最大的边明显（~~并不~~）成立
   3. 所以得到的是MST
2. 还有一种比较滑的归纳法证明，见[oi-wiki](https://oi-wiki.org/graph/mst/#_4)

> 顺便：kruskal的算法实现：[伪代码](https://oi-wiki.org/graph/mst/#_3)





## 树的枚举

建议：因为$n$阶树的边数确定，根据握手定理，其度总和也确定为$2n-2$，所以可以先枚举度数列，然后对每个度数列枚举。注意要保证连通无圈



# 根树

## 定义

### 有向树和根树

首先是有向树：基图是无向树的有向图

然后是根树：根树是有向树，并且满足：只有一个入度为0，出度不为0的点，被称为根点；有若干个入度为1，出度不为0的点，被称为内点；有若干个入度为1，出度为0的点，被称为树叶；没有其他点

另外，根点和内点统称分支点



### 层数和树高

对于一个顶点$v$，其层数$L(v)=$树根到$v$的路径长度

根据定义，根的

树高定义成所有顶点中层数最高的点的层数



### 儿子父亲兄弟祖先

略，看书定义



### 有序树

每一层的结点都被标过号的树



## 特殊的树

### 一些定义

$r$叉树：$\forall v\in V,d^+(v)\le r$

$r-$正则树：$\forall $分支点$v,d^+(v)=r$

$r-$正则完全树：$T$是$r-$正则树，且$\forall $树叶$v$，$L(v)=h(T)$（也就是层高等于树高，或者说所有叶子都在最底层）

<img src="树资源库/截屏2021-04-07 13.04.02.png" style="zoom:50%;" />

（三种树）



### $r-$正则树的定理

设$r-$正则树有$i$个分叉点和$t$个树叶，则$(r-1)i=t-1$

简单理解：把一个树叶替换成分支点，会产生$r$个树叶，但是自身原来是树叶现在不是，所以每多一个分支点多$r-1$个树叶。之后递推就行了

这个定理可以用来解决诸如“墙上只有1个电源插孔，每个接线板有3个插孔，有10台计算机，至少需要多少个接线板？”的问题



## 根子树

### 定义

$T$是根树，$v\in V(T)$，由$v$本身及其所有后代导出的子图$T_v$就是根子树

在二叉树上，还有左根子树和右根子树的概念



## 带权二叉树

### 定义

每个树叶都有指定权值的二叉树

定义带权二叉树的权$W(T)=\sum\limits_{v\ is\ leaf}w_vL(v)$，也就是所有的树叶高度与权值乘积和



### 最优二叉树

树叶权为$w_1,_2,\cdots w_t$的所有二叉树中树权最小的一个



### Huffman算法

用来求最优二叉树

#### 算法流程

<img src="树资源库/截屏2021-04-07 13.22.19.png" style="zoom:40%;" />

求得到的树权可以直接使用定义求，也可以把得到的树除了叶子之外所有的点（也就是分支点）权加起来（分支点的权等于两个子结点的权和）如下图即$25+10+15+5=55$

<img src="树资源库/截屏2021-04-07 13.35.18.png" style="zoom:50%;" />

#### 正确性证明

先写出思路

1. 整个Huffman算法的过程可以看作一个循环的过程：对于一个权值序列，每一次都选择两个权值，使用这两个权值和代替它们

2. 因此想到一个思路

   我们证明：对于任何权值序列$V_0$，如果得到了一个Huffman树$T_0$，其最小的两个数$v_1,v_2$不是兄弟，那么一定可以构造出一个Huffman树$T_H$，使$W(T_H)\le W(T_0)$

   这样，我们可以证明，最小的两个放在一起可以得到最优解

> 这里之前写的证法是错的，这个证法应该没问题，之后会补图





## 编码与前缀码

这里全部讲的是使用0/1的二进制编码

### 编码

编码很简单，就是对于字符集$S_C$里面每个元素使用一个仅含0/1的串表示



### 前缀码

前缀的定义：如果字符串$S_1$是$S_3$的前缀，则$S_3$可以写成$S_3=S_1+S_2$的形式（$+$表示两个字符串前后拼接）

#### 引入

在传输的过程中一般是不加分隔符的，所以我们必须要一个编码$S_1$不是另一个$S_2$的前缀，不然会出现二义性

直接搬老师课件

<img src="树资源库/截屏2021-04-12 12.54.29.png" style="zoom:50%;" />

#### 严格定义

对于字符串集$A=\{\beta_1,\beta_2,\cdots ,\beta_n\}$，如果$A$的任意两个字符串都互不为前缀，则称$A$为前缀码

如果前缀码的字符串都是由0/1构成的，则称为2元前缀码（也就是我们研究的前缀码）



#### 最佳前缀码

不是很能说清楚这玩意应该怎么定义。。。可以翻下书上P338的内容和例题了解是怎么构造的，本质就是Huffman算法的应用

值得一提，如果使用的是频率建立Huffman树，那么最后的树权就是平均每个字符使用的二进制位数

> 这个和 字典树 的概念很像。。。不过字典树就是另一个概念了，而且貌似比这个麻烦



















